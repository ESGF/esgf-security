#!/bin/bash

#####
# ESGF Security Services
# description: Security Services
#
#****************************************************************************
#*                                                                          *
#*   Copyright (c) 2009, Lawrence Livermore National Security, LLC.         *
#*   Produced at the Lawrence Livermore National Laboratory                 *
#*   Written by: Gavin M. Bell (gavin@llnl.gov)                             *
#*   LLNL-CODE-420962                                                       *
#*                                                                          *
#*   All rights reserved. This file is part of the:                         *
#*   Earth System Grid Fed (ESGF) Node Software Stack, Version 1.0          *
#*                                                                          *
#*   For details, see http://esgf.org/                                      *
#*   Please also read this link                                             *
#*    http://esgf.org/LICENSE                                               *
#*                                                                          *
#*   * Redistribution and use in source and binary forms, with or           *
#*   without modification, are permitted provided that the following        *
#*   conditions are met:                                                    *
#*                                                                          *
#*   * Redistributions of source code must retain the above copyright       *
#*   notice, this list of conditions and the disclaimer below.              *
#*                                                                          *
#*   * Redistributions in binary form must reproduce the above copyright    *
#*   notice, this list of conditions and the disclaimer (as noted below)    *
#*   in the documentation and/or other materials provided with the          *
#*   distribution.                                                          *
#*                                                                          *
#*   Neither the name of the LLNS/LLNL nor the names of its contributors    *
#*   may be used to endorse or promote products derived from this           *
#*   software without specific prior written permission.                    *
#*                                                                          *
#*   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
#*   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
#*   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS      *
#*   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE    *
#*   LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR     *
#*   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,           *
#*   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       *
#*   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF       *
#*   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND    *
#*   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,     *
#*   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT     *
#*   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF     *
#*   SUCH DAMAGE.                                                           *
#*                                                                          *
#****************************************************************************
#####

#uses: perl, awk, ifconfig, tar, wget, curl, su, useradd, groupadd,
#      id, chmod, chown, chgrp, cut, svn, mkdir, killall, java, egrep,
#      lsof, unlink, ln, pax, keytool, openssl

#note: usage of readlink not macosx friendly :-( usage of useradd /
#      groupadd is RedHat/CentOS dependent :-(

DEBUG=${DEBUG:-0}
VERBOSE=${VERBOSE:-0}
envfile="/etc/esg.env"

esg_dist_url=${esg_dist_url:-"http://198.128.245.140/dist"}

#Maybe I am paranoid but I want to make sure someone can't just set
#the environment to any place and have us just accept it and pull from
#it -gavin
if $(echo "${esg_dist_url}" | grep "http://198.128.245.140/dist" >& /dev/null); then echo "*"; else (echo "illegal distribution url: ${esg_dist_url}" && checked_done 1); fi


#--------------
#User Defined / Setable (public)
#--------------
install_prefix=${install_prefix:-"/usr/local"}
cdat_home=${cdat_home:-${install_prefix}/cdat}
esg_root_dir=${esg_root_dir:-"/esg"}
workdir=${workdir:-~/workbench/esg}
install_manifest=${install_manifest:-"${esg_root_dir}/esgf-install-manifest"}
#--------------

date_format=${date_format:-"+%Y_%m_%d_%H%M%S"}
force_install=${force_install:-0}

tomcat_user=${tomcat_user:-tomcat}
tomcat_group=${tomcat_group:-$tomcat_user}
tomcat_install_dir=${CATALINA_HOME:-${install_prefix}/tomcat}
python_version=${python_version:-"2.6"}
config_file=${esg_root_dir}/config/esgf.properties

security_web_service_name="esgf-security"
esgf_user_migration_launcher="esgf-user-migrate"


init() {
    #[ -n "${envfile}" ] && [ -e "${envfile}" ] && source ${envfile} && ((VERBOSE)) && printf "security services: sourcing environment from: ${envfile} \n"

    security_dist_url=${esg_dist_url}/esgf-security/esgf-security.war
    security_app_context_root=${security_web_service_name:-esgf-security}
    security_app_home=${tomcat_install_dir}/webapps/${security_app_context_root}

    security_attribute_service_host=${security_attribute_service_host:-${esgf_host:-$(hostname --fqdn)}}
    security_attribute_service_port=${security_attribute_service_post:-"443"}
    security_attribute_service_endpoint=$(echo "https://${security_attribute_service_host}$( if ((security_attribute_service_port != 443)); then echo ":${secuirty_attribute_service_port}"; fi)/esgf-security/saml/soap/secure/attributeService.htm")

    security_authz_service_host=${security_authz_service_host:-${esgf_host:-$(hostname --fqdn)}}
    security_authz_service_port=${security_authz_service_post:-"443"}
    security_authz_service_endpoint=$(echo "https://${security_authz_service_host}$( if ((security_authz_service_port != 443)); then echo ":${security_authz_service_port}"; fi)/esgf-security/saml/soap/secure/authorizationService.htm")
    
    security_registration_service_host=${security_registration_service_host:-${esgf_host:-$(hostname --fqdn)}}
    security_registration_service_port=${security_registration_service_post:-"443"}
    security_registration_service_endpoint=$(echo "https://${security_registration_service_host}$( if ((security_registration_service_port != 443)); then echo ":${security_registration_service_port}"; fi)/esgf-security/secure/registrationService.htm")

    esgf_security_version=${esgf_security_version:-"1.2.8"}
    esgf_security_db_version=${esgf_security_db_version:-"0.1.4"}
    esgf_security_egg_file=esgf_security-${esgf_security_db_version}-py${python_version}.egg
    
    #Database information....
    node_db_name=${node_db_name:-"esgcet"}
    postgress_driver=${postgress_driver:-org.postgresql.Driver}
    postgress_protocol=${postgress_protocol:-jdbc:postgresql:}
    postgress_host=${PGHOST:-localhost}
    postgress_port=${PGPORT:-5432}
    postgress_user=${PGUSER:-dbsuper}
    pg_sys_acct_passwd=${pg_sys_acct_passwd:=${pg_secret:=changeme}}
    setup_policy_files >& /dev/null
}


#####
# Install The ESGF Security Services
#####
# - Takes boolean arg: 0 = setup / install mode (default)
#                      1 = updated mode
#
# In setup mode it is an idempotent install (default)
# In update mode it will always pull down latest after archiving old
#
setup_security() {
    init

    echo -n "Checking for security services ${esgf_security_version}"
    check_webapp_version "${security_app_context_root}" "${esgf_security_version}"
    local ret=$?
    ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0
    
    echo
    echo "*******************************"
    echo "Setting up The ESGF Security Services"
    echo "*******************************"
    echo

    local upgrade=${1:-0}

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -d ${security_app_home} ]; then 
        echo "Detected an existing security services installation..."
        read -p "Do you want to continue with security services installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z "${dosetup}" ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping security services installation and setup - will assume it's setup properly"
            return 0
        fi
        
        local dobackup="Y"
        read -p "Do you want to make a back up of the existing distribution?? [Y/n] " dobackup
        [ -z "${dobackup}" ] && dobackup=${default}
        if [ "${dobackup}" = "Y" ] || [ "${dobackup}" = "y" ]; then
            echo "Creating a backup archive of this web application $security_app_home"
            backup ${security_app_home}
        fi

        echo
    fi

    configure_postgress

    mkdir -p ${workdir}
    [ $? != 0 ] && return 1
    pushd ${workdir} >& /dev/null

    local security_dist_file=$(pwd)/${security_dist_url##*/}
    checked_get ${security_dist_file} ${security_dist_url} $((force_install))
    (( $? > 1 )) && echo " ERROR: Could not download ${node_dist_url} :-(" && popd >& /dev/null && checked_done 1
    
    stop_tomcat

    #make room for new install
    if (( force_install )) ; then
        echo "Removing Previous Installation of the ESGF Security Services..."
        [ -d "${security_app_home}" ] && rm -rf ${security_app_home} || echo "WARNING: Strange, can't locate previous install @ ${security_app_home}"
    fi
    
    #----------------------------
    mkdir -p ${security_app_home}
    [ $? != 0 ] && echo "Could not create dir ${security_app_home}" && popd >& /dev/null && checked_done 1
    cd ${security_app_home}
    echo "Expanding war ${security_dist_file} in $(pwd)"
    $JAVA_HOME/bin/jar xf ${security_dist_file}
    
    chown -R ${tomcat_user} ${security_app_home}
    chgrp -R ${tomcat_group} ${security_app_home}
    popd >& /dev/null
    #----------------------------
    
    popd >& /dev/null

    setup_policy_files
    fetch_user_migration_launcher

    write_security_install_log
    checked_done 0

}

write_security_install_log() {
    echo "$(date ${date_format}) webapp:${security_app_context_root}=${esgf_security_version} ${security_app_home}" >> ${install_manifest}
    dedup ${install_manifest}
    write_as_property security_app_home
    write_as_property security_authz_service_endpoint
    write_as_property security_attribute_service_endpoint
    write_as_property security_registration_service_endpoint
    return 0
}

#--------------------------------------------------
#NOTE: This must be run AFTER the esg node web app
#      installation/configuration (setup_node_manager) 
#--------------------------------------------------
configure_postgress() {
    init

    echo
    echo "*******************************"
    echo "Configuring Postgres... for ESGF Security"
    echo "*******************************"
    echo
    
    start_postgress

    #Create the database...
    echo "Creating esg node database: [${node_db_name}]"
    echo "${postgress_install_dir}/bin/createdb ${node_db_name}"
    PGPASSWORD=${PGPASSWORD:-${pg_sys_acct_passwd}:-${security_admin_password}} ${postgress_install_dir}/bin/createdb ${node_db_name} >& /dev/null
    (( $? > 1 )) && echo " ERROR: Could not create esg node database: ${node_db_name}" && return 0
    echo 

    mkdir -p ${workdir}/${node_dist_dir:-esgf-security-${esgf_security_version}}/db
    pushd ${workdir}/${node_dist_dir:-esgf-security-${esgf_security_version}}/db >& /dev/null
    [ $? != 0 ] && echo " ERROR: Could not find node distribution dir ${workdir}/${node_dist_dir}" && checked_done 1

    #------------------------------------------------------------------------
    #Based on the node type selection we build the appropriate database tables
    #------------------------------------------------------------------------
    
    #download the egg file from the distribution server is necessary....
    checked_get ${esgf_security_egg_file} ${esg_dist_url}/esgf-security/${esgf_security_egg_file} $((force_install))
    (( $? > 1 )) && return 0

    #install the egg....
    ((DEBUG)) && "$cdat_home/bin/easy_install ${esgf_security_egg_file}"
    $cdat_home/bin/easy_install ${esgf_security_egg_file}
    [ $? != 0 ] && echo "ERROR: Could not create esgf security python module" && checked_done 1

    #run the code to build the database and install sql migration...
    ((DEBUG)) && echo "$cdat_home/bin/esgf_security_initialize --dburl ${postgress_user}:${pg_sys_acct_passwd}@${postgress_host}:${postgress_port}/${node_db_name} -c"
    $cdat_home/bin/esgf_security_initialize --dburl ${postgress_user}:${pg_sys_acct_passwd}@${postgress_host}:${postgress_port}/${node_db_name} -c
    [ $? != 0 ] && echo "ERROR: Could not create esgf security database tables in ${node_db_name}" && checked_done 1
    
    write_security_db_install_log
    echo
    
    popd >& /dev/null
    echo
    echo
    checked_done 0
}



write_security_db_install_log() {
    echo "$(date ${date_format}) python:esgf_security=${esgf_security_db_version} " >> ${install_manifest}
    dedup ${install_manifest}
    return 0
}

#--------------------------------------
# Clean / Uninstall this module...
#--------------------------------------

clean_security_webapp_subsystem() {
    init
    local doit="N"
    if [ -e ${security_app_home} ]; then
        read -p "remove ESGF Security web service? (${security_app_home}) [y/N]: " doit
        if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
            echo "removing ${tomcat_install_dir}/webapps/${security_app_context_root}"
            if [ -n ${security_app_home} ]; then
                rm -rf ${security_app_home}
                [ $? != 0 ] && echo "ERROR: Unable to remove ${tomcat_install_dir}/webapps/${security_app_context_root}" && return 1
                perl -n -i -e'print unless m!webapp:esgf-security!' ${install_manifest}
                remove_property security_app_home
                remove_property security_authz_service_endpoint
                remove_property security_attribute_service_endpoint
                remove_property security_registration_service_endpoint
            fi
        fi
    fi 
    return 0
}

#NOTE: There are certain fields that we are not pulling from (node_db_name and postgress_host).
#      If the fit hits the shan I want to make it clear that we are not nuking anyone else's database, etc.
#      strictly the "esgcet" database on "localhost"
clean_security_database_subsystem_installation() {
    init
    local doit="N"

    read -p "remove ESGF Security database, database subsystem AND DATA? (esgf_security.*) [y/N]: " doit
    if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
        if $(psql -U ${postgress_user} esgcet -c "\dt esgf_security.;" | egrep '^\([1-9]* row[s]?\)' >& /dev/null); then
            
            #Call me paranoid but I want some integrity check that this code is what is meant to be straight from the distribution.
            diff <(md5sum ${scripts_dir}/esg-security | tr -s " " | cut -d " " -f 1) <(curl -s -L --insecure ${esg_dist_url}/esgf-security/esg-security.md5 | tr -s " " | cut -d " " -f 1) >& /dev/null
            [ $? != 0 ] && echo " WARNING: Could not verify ${scripts_dir}/esg-security, aborting this uninstall" && return 3
            echo "[VERIFIED]"
            
            backup_db esgcet security
            echo "removing esgf_security.* schema and tables and DATA"
            ${cdat_home}/bin/esgf_security_initialize --dburl ${postgress_user}:${pg_sys_acct_passwd}@localhost:${postgress_port}/esgcet -d 0
            [ $? != 0 ] && echo "ERROR: Unable to remove ${tomcat_install_dir}/webapps/${security_app_context_root}" && return 1
            rm -rvf ${cdat_home}/bin/esgf_security_initialize && \
                rm -rf ${cdat_home}/lib/python${python_version}/${esgf_security_egg_file} && \
                perl -n -i -e'print unless m!python:esgf_security!' ${install_manifest} && echo "[REMOVED]"
        else
            echo " Could not find security tables in the database."
        fi 
    fi
    return 0
}

fetch_user_migration_launcher() {
    pushd ${scripts_dir} >& /dev/null
    checked_get ${esgf_user_migration_launcher} ${esg_dist_url}/${security_web_service_name}/${esgf_user_migration_launcher} $((force_install))
    (( $? > 1 )) && echo " ERROR: Could not download ${esg_dist_url}/${security_web_service_name}/${esgf_user_migration_launcher} :-(" && popd >& /dev/null && return 1
    chmod 755 ${esgf_user_migration_launcher}
    popd >& /dev/null
    return 0
}

setup_policy_files() {
    debug_print "setup_policy_files()... "
    local policy_file_name="esgf_policies"
    local policy_file_dist_dir="${security_app_home:-/usr/local/tomcat/webapps/esgf-security}/WEB-INF/classes/esg/security/config"

    #If old named file exists rename
    # esgf_polcies.xml -> esgf_policies_local.xml
    [ -f "${esg_config_dir}/${policy_file_name}.xml" ] && mv -v "${esg_config_dir}/${policy_file_name}{,_local}.xml"
    # esgf_polcies_static.xml -> esgf_policies_common.xml
    [ -f "${esg_config_dir}/${policy_file_name}_static.xml" ] && mv -v "${esg_config_dir}/${policy_file_name}{_static,_common}.xml"

    if [ ! -f "${esg_config_dir}/${policy_file_name}_local.xml" ] && [ -f "${policy_file_dist_dir}/${policy_file_name}_local.xml" ]; then
        cp -v ${policy_file_dist_dir}/${policy_file_name}_local.xml ${esg_config_dir}
        chown ${tomcat_user}:${tomcat_group} ${esg_config_dir}/${policy_file_name}_local.xml && \
            chmod 640 ${esg_config_dir}/${policy_file_name}_local.xml
    fi

    if [ ! -f "${esg_config_dir}/${policy_file_name}_common.xml" ] && [ -f "${policy_file_dist_dir}/${policy_file_name}_common.xml" ]; then
        cp -v ${policy_file_dist_dir}/${policy_file_name}_common.xml ${esg_config_dir}
        chown ${tomcat_user}:${tomcat_group} ${esg_config_dir}/${policy_file_name}_common.xml && \
            chmod 640 ${esg_config_dir}/${policy_file_name}_common.xml
    else
        if [  -f "${policy_file_dist_dir}/${policy_file_name}_common.xml" ]; then
            if (diff <(md5sum_ "${esg_config_dir}/${policy_file_name}_common.xml" | awk ' {print $1}') <(md5sum_ "${policy_file_dist_dir}/${policy_file_name}_common.xml" | awk ' {print $1}')); then
                echo "Detected change in common policy file... replacing with distribution's common policy file"
                mv -v ${esg_config_dir}/${policy_file_name}_common.xml{,.bak}
                cp -v ${policy_file_dist_dir}/${policy_file_name}_common.xml "${esg_config_dir}"
            fi
        fi
    fi
}

_fetch_static_ats_whitelist() {
    local config_dir=${esg_config_dir}
    local static_list_file="esgf_ats_static.xml"
    if [ -d "${config_dir:-/esg/config}" ]; then
        if [ -e "${config_dir}/${static_list_file}" ] && debug_print "${config_dir}/${static_list_file} is present will NOT fetch from distribution site" && return 0
        checked_get ${config_dir}/${static_list_file} ${esg_dist_url}/lists/${static_list_file} $((force_install))
        (( $? > 1 )) && echo debug_print "[DEBUG]: Could not fetch ${static_list_file} from distribution server" && return 1
        chown -R ${tomcat_user}:${tomcat_group} ${config_dir}/${static_list_file}
        chmod 644 ${config_dir}/${static_list_file}
    fi
    return 0
}

#--------------------------------------
# Callout function from esg-node
#--------------------------------------
#This function is called by esg-node before starting tomcat!
#This is how we make sure we are always using the proper credentials.
security_startup_hook() {
    echo -n "Security Startup Hook:... "
    _fetch_static_ats_whitelist && echo "[OK]" || echo "[FAIL]"
}

#-------------------
#Utility function, wraps md5sum so it may be used on either mac or
#linux machines
md5sum_() {
    hash -r
    if type md5sum >& /dev/null; then
        echo $(md5sum $@)
    else
        echo $(md5 $@ | sed -n 's/MD5[ ]*\(.*\)[^=]*=[ ]*\(.*$\)/\2 \1/p')
    fi
}
#-------------------
